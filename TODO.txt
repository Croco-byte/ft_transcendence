	Quentin :

>> Ajouter un check de file extension / de taille de fichier sur l'upload des avatars utilisateurs.
>> Ajouter de la gestion d'erreur en cas d'échec de l'upload d'un avatar utilisateur (pour le moment, le backend ne renvoie jamais d'erreur)
>> Ajouter de la gestion d'erreur pour l'affichage des pages utilisateurs, et l'envoi des friend requests (par exemple envoi à des utilisateurs inexistants)
>> Gestion d'erreur dans la récupération du status de la friend request (pénible avec les Observables tho)

>> Backend, profile.service.ts : retirer 2FA, 2FA secret etc... de la réponse du backend pour la fonction getAccount

>> [DONE] Refresh automatiquement la page "Friends" toutes les 10 secondes pour update amis et requêtes

>> [DONE] Permettre aux utilisateurs d'unfriend (attention pagination : si la page actuelle n'a plus de friends, passer à la page précédente)
>> [DONE] Lorsqu'une friend request a été déclinée par le receiver, seul le receiver peut envoyer une nouvelle friend request à l'autre utilisateur 

>> [DONE] Lorsqu'une recherche utilisateurs ne retourne aucun résultat, afficher un message
>> [DONE] Paginate friends / received friend requests / sent friend requests



>> [DONE] Quand je suis 'online' avec un utilisateur, et que j'ai 2 fenêtres où je suis connecté avec cet utilisateur, si je ferme une fenêtre, alors ça me marquera offline sur la fenêtre où je suis encore connecté.
	2 solutions :
		> Essayer d'éviter de set "offline".
		> Empêcher un utilisateur d'être connecté simultanément sur plusieurs fenêtres.

Pour l'option 1 :
https://stackoverflow.com/questions/13364243/websocketserver-node-js-how-to-differentiate-clients

>> Pour les websockets des statuts utilisateurs, sur le front, retirer les listeners quand le composant qui l'utilise est
destroyed. Sinon, quand je vais sur la page d'un utilisateur, puis sur Friends, et que j'intéragis avec cet utilisateur --> voir ce qu'il se passe

>> [DONE] Envoyer un signal websocket à l'envoi d'une friendrequest

>> Parfois, à la première connexion (sur Chrome ?), on se fait kick car le backend détecte que l'utilisateur est déjà online. Vérifier que quand on quitte tout est bien offline,
vérifier que deux signaux "setOnline" ne sont pas envoyés.
En fait, on a probablement un problème de design lors de l'opération de Login. Lorsque je reviens de l'OAuth 42, l'opération de login automatique est probablement déclenchée,
puisque je recharge la page ; et l'opération de login classique est également déclenchée.

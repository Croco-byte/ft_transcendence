import { Observable } from 'rxjs';
import { Repository } from 'typeorm';
import { FriendRequest, FriendRequestStatus, FriendRequest_Status } from './friend-request.interface';
import { FriendRequestEntity } from './friends-request.entity';
import { User } from './users.entity';
import { UserWithRank } from './user.interface';
import { Pagination, IPaginationOptions } from 'nestjs-typeorm-paginate';
import { UserStatus, User_Status } from './status.interface';
export declare class UsersService {
    private usersRepository;
    private friendRequestRepository;
    constructor(usersRepository: Repository<User>, friendRequestRepository: Repository<FriendRequestEntity>);
    private logger;
    setTwoFactorAuthenticationSecret(secret: string, id: number): Promise<import("typeorm").UpdateResult>;
    turnOnTwoFactorAuthentication(id: number): Promise<import("typeorm").UpdateResult>;
    turnOffTwoFactorAuthentication(id: number): Promise<import("typeorm").UpdateResult>;
    findUserById(id: number): Promise<User>;
    getUserRank(id: number): Promise<number>;
    getCurrUserStatus(currUser: User): Observable<UserStatus>;
    getUserStatus(userId: number): Observable<UserStatus>;
    changeUserdisplayname(id: number, newdisplayname: string): Promise<string>;
    updateAvatar(id: number, filename: string): Promise<void>;
    changeUserStatus(userId: number, targetStatus: User_Status): Promise<void>;
    isUserAlreadyBlocked(currUser: User, blockedUser: User): Promise<string>;
    blockUser(currUserId: number, blockedUserId: number): Promise<void>;
    unBlockUser(currUserId: number, blockedUserId: number): Promise<void>;
    getFriendRequestById(friendRequestId: number): Promise<FriendRequest>;
    sendFriendRequest(receiverId: number, creatorId: number): Promise<FriendRequest>;
    reSendFriendRequest(creator: User, receiver: User): Promise<FriendRequest>;
    respondToFriendRequest(friendRequestId: number, responseStatus: FriendRequest_Status): Promise<FriendRequest>;
    hasFriendRequestBeenSentOrReceived(creator: User, receiver: User): Promise<string>;
    getFriendRequestStatus(receiverId: number, currentUser: User): Promise<FriendRequestStatus>;
    unfriendUser(currUserId: number, friendId: number): Promise<{
        creatorId: number;
        receiverId: number;
    }>;
    cancelFriendRequest(currUserId: number, receiverId: number): Promise<{
        creatorId: number;
        receiverId: number;
    }>;
    paginateUsers(options: IPaginationOptions): Promise<Pagination<User>>;
    paginateUsersOrderByScore(options: IPaginationOptions): Promise<Pagination<UserWithRank>>;
    paginateUsersFilterBydisplayname(options: IPaginationOptions, displayname: string): Observable<Pagination<User>>;
    paginateFriends(options: IPaginationOptions, currentUser: User): Observable<Pagination<User>>;
    paginateFriendRequestsFromRecipients(options: IPaginationOptions, currentUser: User): Observable<Pagination<FriendRequest>>;
    paginateFriendRequestsToRecipients(options: IPaginationOptions, currentUser: User): Observable<Pagination<FriendRequest>>;
    getWebsiteOwner(): Promise<User>;
    getWebsiteModerators(options: IPaginationOptions): Promise<Pagination<User>>;
    getWebsiteBlockedUsersPaginated(options: IPaginationOptions): Promise<Pagination<User>>;
    makeUserModerator(userId: number): Promise<void>;
    makeUserRegular(userId: number): Promise<void>;
    blockWebsiteUser(userId: number): Promise<void>;
    unblockWebsiteUser(userId: number): Promise<void>;
    insert(user: User): Promise<User>;
    findAll(): Promise<User[]>;
    findOne(id: string): Promise<User>;
    findByUsername(name: string): Promise<User>;
    findById(id: string): Promise<User>;
    delete(id: string): Promise<void>;
    save(user: User): Promise<void>;
    incUserWins(userDbId: number): Promise<void>;
    incUserLoses(userDbId: number): Promise<void>;
    updateRoomId(userDbId: number, newRoomId: string): Promise<User>;
    resetRoomId(roomToReset: string): Promise<void>;
    rankUsers(): Promise<User[]>;
    getBiDirectionalBlockedUsers(user: User): Promise<User[]>;
}
